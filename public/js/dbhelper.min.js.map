{"version":3,"sources":["dbhelper.js"],"names":["DBHelper","DATABASE_URL","[object Object]","callback","xhr","XMLHttpRequest","open","onload","status","restaurants","JSON","parse","responseText","error","send","id","fetchRestaurants","restaurant","find","r","cuisine","results","filter","cuisine_type","neighborhood","neighborhoods","map","v","i","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","photograph","google","maps","Marker","position","latlng","title","name","url","urlForRestaurant","animation","Animation","DROP"],"mappings":"AAGA,MAAMA,SAKJC,0BAEE,MAAO,8CAMTC,wBAAwBC,GACtB,MAAMC,EAAM,IAAIC,eAChBD,EAAIE,KAAK,MAAON,SAASC,cACzBG,EAAIG,OAAS,MACX,GAAmB,MAAfH,EAAII,OAAgB,CAEtB,MACMC,EADOC,KAAKC,MAAMP,EAAIQ,cACHH,YACzBN,EAAS,KAAMM,OACV,CAEL,MAAMI,wCAA8CT,EAAII,SACxDL,EAASU,EAAO,SAGpBT,EAAIU,OAMNZ,2BAA2Ba,EAAIZ,GAE7BH,SAASgB,iBAAiB,CAACH,EAAOJ,KAChC,GAAII,EACFV,EAASU,EAAO,UACX,CACL,MAAMI,EAAaR,EAAYS,KAAKC,GAAKA,EAAEJ,IAAMA,GAC7CE,EAEFd,EAAS,KAAMc,GAGfd,EAAS,4BAA6B,SAS9CD,gCAAgCkB,EAASjB,GAEvCH,SAASgB,iBAAiB,CAACH,EAAOJ,KAChC,GAAII,EACFV,EAASU,EAAO,UACX,CAEL,MAAMQ,EAAUZ,EAAYa,OAAOH,GAAKA,EAAEI,cAAgBH,GAC1DjB,EAAS,KAAMkB,MAQrBnB,qCAAqCsB,EAAcrB,GAEjDH,SAASgB,iBAAiB,CAACH,EAAOJ,KAChC,GAAII,EACFV,EAASU,EAAO,UACX,CAEL,MAAMQ,EAAUZ,EAAYa,OAAOH,GAAKA,EAAEK,cAAgBA,GAC1DrB,EAAS,KAAMkB,MAQrBnB,+CACEkB,EACAI,EACArB,GAGAH,SAASgB,iBAAiB,CAACH,EAAOJ,KAChC,GAAII,EACFV,EAASU,EAAO,UACX,CACL,IAAIQ,EAAUZ,EACC,OAAXW,IAEFC,EAAUA,EAAQC,OAAOH,GAAKA,EAAEI,cAAgBH,IAE9B,OAAhBI,IAEFH,EAAUA,EAAQC,OAAOH,GAAKA,EAAEK,cAAgBA,IAElDrB,EAAS,KAAMkB,MAQrBnB,0BAA0BC,GAExBH,SAASgB,iBAAiB,CAACH,EAAOJ,KAChC,GAAII,EACFV,EAASU,EAAO,UACX,CAEL,MAAMY,EAAgBhB,EAAYiB,IAChC,CAACC,EAAGC,IAAMnB,EAAYmB,GAAGJ,cAGrBK,EAAsBJ,EAAcH,OACxC,CAACK,EAAGC,IAAMH,EAAcK,QAAQH,IAAMC,GAExCzB,EAAS,KAAM0B,MAQrB3B,qBAAqBC,GAEnBH,SAASgB,iBAAiB,CAACH,EAAOJ,KAChC,GAAII,EACFV,EAASU,EAAO,UACX,CAEL,MAAMkB,EAAWtB,EAAYiB,IAAI,CAACC,EAAGC,IAAMnB,EAAYmB,GAAGL,cAEpDS,EAAiBD,EAAST,OAC9B,CAACK,EAAGC,IAAMG,EAASD,QAAQH,IAAMC,GAEnCzB,EAAS,KAAM6B,MAQrB9B,wBAAwBe,GACtB,8BAA+BA,EAAWF,KAM5Cb,6BAA6Be,GAC3B,gBAAiBA,EAAWgB,aAM9B/B,8BAA8Be,EAAYS,GAQxC,OAPe,IAAIQ,OAAOC,KAAKC,OAAO,CACpCC,SAAUpB,EAAWqB,OACrBC,MAAOtB,EAAWuB,KAClBC,IAAKzC,SAAS0C,iBAAiBzB,GAC/BS,IAAAA,EACAiB,UAAWT,OAAOC,KAAKS,UAAUC","sourcesContent":["/**\n * Common database helper functions.\n */\nclass DBHelper {\n  /**\n   * Database URL.\n   * Change this to restaurants.json file location on your server.\n   */\n  static get DATABASE_URL() {\n    const port = 3000; // Change this to your server port\n    return `http://localhost:${port}/data/restaurants.json`;\n  }\n\n  /**\n   * Fetch all restaurants.\n   */\n  static fetchRestaurants(callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', DBHelper.DATABASE_URL);\n    xhr.onload = () => {\n      if (xhr.status === 200) {\n        // Got a success response from server!\n        const json = JSON.parse(xhr.responseText);\n        const restaurants = json.restaurants;\n        callback(null, restaurants);\n      } else {\n        // Oops!. Got an error from server.\n        const error = `Request failed. Returned status of ${xhr.status}`;\n        callback(error, null);\n      }\n    };\n    xhr.send();\n  }\n\n  /**\n   * Fetch a restaurant by its ID.\n   */\n  static fetchRestaurantById(id, callback) {\n    // fetch all restaurants with proper error handling.\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        const restaurant = restaurants.find(r => r.id == id);\n        if (restaurant) {\n          // Got the restaurant\n          callback(null, restaurant);\n        } else {\n          // Restaurant does not exist in the database\n          callback('Restaurant does not exist', null);\n        }\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine type with proper error handling.\n   */\n  static fetchRestaurantByCuisine(cuisine, callback) {\n    // Fetch all restaurants  with proper error handling\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given cuisine type\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given neighborhood\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByCuisineAndNeighborhood(\n    cuisine,\n    neighborhood,\n    callback,\n  ) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        let results = restaurants;\n        if (cuisine != 'all') {\n          // filter by cuisine\n          results = results.filter(r => r.cuisine_type == cuisine);\n        }\n        if (neighborhood != 'all') {\n          // filter by neighborhood\n          results = results.filter(r => r.neighborhood == neighborhood);\n        }\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * Fetch all neighborhoods with proper error handling.\n   */\n  static fetchNeighborhoods(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all neighborhoods from all restaurants\n        const neighborhoods = restaurants.map(\n          (v, i) => restaurants[i].neighborhood,\n        );\n        // Remove duplicates from neighborhoods\n        const uniqueNeighborhoods = neighborhoods.filter(\n          (v, i) => neighborhoods.indexOf(v) == i,\n        );\n        callback(null, uniqueNeighborhoods);\n      }\n    });\n  }\n\n  /**\n   * Fetch all cuisines with proper error handling.\n   */\n  static fetchCuisines(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all cuisines from all restaurants\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type);\n        // Remove duplicates from cuisines\n        const uniqueCuisines = cuisines.filter(\n          (v, i) => cuisines.indexOf(v) == i,\n        );\n        callback(null, uniqueCuisines);\n      }\n    });\n  }\n\n  /**\n   * Restaurant page URL.\n   */\n  static urlForRestaurant(restaurant) {\n    return `./restaurant.html?id=${restaurant.id}`;\n  }\n\n  /**\n   * Restaurant image URL.\n   */\n  static imageUrlForRestaurant(restaurant) {\n    return `../img/${restaurant.photograph}`;\n  }\n\n  /**\n   * Map marker for a restaurant.\n   */\n  static mapMarkerForRestaurant(restaurant, map) {\n    const marker = new google.maps.Marker({\n      position: restaurant.latlng,\n      title: restaurant.name,\n      url: DBHelper.urlForRestaurant(restaurant),\n      map,\n      animation: google.maps.Animation.DROP,\n    });\n    return marker;\n  }\n}\n"],"file":"dbhelper.min.js"}